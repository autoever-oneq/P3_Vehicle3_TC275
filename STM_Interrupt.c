/**********************************************************************************************************************
 * \file STM_Interrupt.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "STM_Interrupt.h"
#include "Bsp.h"
#include "IfxPort.h"
#include "IfxStm.h"

#include "IfxGpt12_IncrEnc.h"

#include "PID_CON.h"

#include "GTM_ATOM_PWM.h"




/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_STM        120                              /* Priority for interrupt ISR                       */
#define TIMER_INT_TIME          10                             /* Time between interrupts in ms                    */

//#define LED                     &MODULE_P13,0                   /* LED toggled in Interrupt Service Routine (ISR)   */
#define STM                     &MODULE_STM0                    /* STM0 is used in this example                     */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxStm_CompareConfig g_STMConf;                                 /* STM configuration structure                      */
Ifx_TickTime g_ticksFor1ms;                                   /* Variable to store the number of ticks to wait    */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
//void initLED(void);
//void initSTM(void);
extern void Encoder_update(void);
extern void Encoder_updateB(void); //추가
/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Interrupt Service Routine.
 * This macro makes following definitions:
 * 1) Define linker section as .intvec_tc<vector number>_<interrupt priority>.
 * 2) define compiler specific attribute for the interrupt functions.
 * 3) define the Interrupt service routine as ISR function.
 *
 * IFX_INTERRUPT(isr, vectabNum, priority)
 *  - isr: Name of the ISR function.
 *  - vectabNum: Vector table number.
 *  - priority: Interrupt priority. Refer Usage of Interrupt Macro for more details.
 */

//IFX_INTERRUPT(isrSTM, 0, ISR_PRIORITY_STM);

extern IfxGpt12_IncrEnc_Config gpt12Config;
extern IfxGpt12_IncrEnc_Config gpt12ConfigB;
extern uint32 CPR;
sint32 Enc_count_new = 0;
sint32 Enc_count_old = 0;
float32 Enc_count_diff = 0;
float32 motor_speed_rpm=0;

sint32 Enc_count_newB = 0; // 추가
sint32 Enc_count_oldB = 0;
float32 Enc_count_diffB = 0;
float32 motor_speed_rpmB=0;

PIDREG3 speed_pid = PIDREG3_DEFAULTS;
PIDREG3 speed_pidB = PIDREG3_DEFAULTS; // 추가

volatile float32 Kp_s=4,Ki_s=0.5,Kd_s=0;
float32 s_T_samp= 0.001*TIMER_INT_TIME; // 스케줄링 주기에 맞춰주기
float32 RPM_max = 330, RPM_min = -330;

extern float32 RPM_CMD1;
extern float32 RPM_CMD2;

//void pid_reset(PIDREG3 *v);

float tan_table[25] = {
  -1.73, -1.43, -1.19, -1.00, -0.84, -0.70, -0.58, -0.47, -0.36, -0.27, -0.18, -0.09, // -60° ~ -5°
  0.00,  // 0°
  0.09, 0.18, 0.27, 0.36, 0.47, 0.58, 0.70, 0.84, 1.00, 1.19, 1.43, 1.73  // 5° ~ 60°
}; // 조향 알고리즘 성분

volatile float32 testC = 0;
volatile float32 test_temp = 0;
void RPM_cal(void)
{
    Encoder_update();   //지워도 되는지 확인할것 나중에 지울 것
    Encoder_updateB(); // 일단 추가

    Enc_count_new = gpt12Config.module->T2.U;
    Enc_count_diff = (float32)(Enc_count_new - Enc_count_old); // 밑에 코드는 엔코더에서 읽은 값을 강제로 양수로 만듬(모터 회전이 반대로 되야 함)
    //Enc_count_diff = (Enc_count_new - Enc_count_old > 2000) ? Enc_count_diff : (float32)((Enc_count_new - Enc_count_old) * (-1));
    motor_speed_rpm = Enc_count_diff/(float32)CPR/(float32)(TIMER_INT_TIME*0.001)*60.0f;
    Enc_count_old = Enc_count_new;

    // 추가 내용 여기 값이 계속 초기화됨
//    testC = gpt12ConfigB.module->T4.U; // 0, 1 만 받아짐
    Enc_count_newB = gpt12ConfigB.module->T4.U; // 자료형 다름
    //Enc_count_diffB = (float32)(Enc_count_newB - Enc_count_oldB);
    Enc_count_diffB = (Enc_count_newB - Enc_count_oldB > 2000) ? Enc_count_diffB : (float32)((Enc_count_newB - Enc_count_oldB) * (-1));
    motor_speed_rpmB = Enc_count_diffB/(float32)CPR/(float32)(TIMER_INT_TIME*0.001)*60.0f;
    Enc_count_oldB = Enc_count_newB;
}

void PI_const_update(void) // 튜닝이 끝나면 main문에서 한번만 선언해도 될 듯
{

    speed_pid.Kp = Kp_s;
    speed_pid.Ki = Ki_s;
    speed_pid.Kd = Kd_s;
    speed_pid.Kc = 1/Kp_s;
    speed_pid.T_samp = s_T_samp;
//        speed_pid.Current_mode = 1;
    speed_pid.OutMax = RPM_max;
    speed_pid.OutMin = RPM_min;

    speed_pidB.Kp = Kp_s; // 새로 추가
    speed_pidB.Ki = Ki_s;
    speed_pidB.Kd = Kd_s;
    speed_pidB.Kc = 1/Kp_s;
    speed_pidB.T_samp = s_T_samp; // 주기 바뀌면 s_T_samp 바뀌어야 함
//        speed_pid.Current_mode = 1;
    speed_pidB.OutMax = RPM_max;
    speed_pidB.OutMin = RPM_min;

}
void PI_Speed_con(void) // 이거 지금 안씀
{
//    RPM_Err = RPM_CMD - motor_speed_rpm;
    PI_const_update();
    // Initialze the PID module for Current
    if(RPM_CMD1==0)
    {
        speed_pid.reset((void *)&speed_pid);
        setMotorControl(0,0);

    }
    else
    {
        speed_pid.Ref=RPM_CMD1;   // speed reference
        speed_pid.Fdb= motor_speed_rpm; // speed measured by ENC
        speed_pid.calc((void *)&speed_pid);   // Calculate speed PID Controller
    }


    if(RPM_CMD2==0)
    {
        speed_pidB.reset((void *)&speed_pidB);
        setMotorControlB(0,0);
    }
    else
    {
        speed_pidB.Ref=RPM_CMD2;   // speed reference float32
        speed_pidB.Fdb= motor_speed_rpmB; // speed measured by ENC
        speed_pidB.calc((void *)&speed_pidB);   // Calculate speed PID Controller
    }

}


void isrSTM(void)
{
    /* Update the compare register value that will trigger the next interrupt and toggle the LED */
//    IfxPort_setPinState(LED, IfxPort_State_toggled);
    RPM_cal();
    speed_pid.Fdb= motor_speed_rpm; // speed measured by ENC
    speed_pid.calc((void *)&speed_pid);   // Calculate speed PID Controller
    speed_pidB.Fdb= motor_speed_rpmB; // speed measured by ENC
    speed_pidB.calc((void *)&speed_pidB);   // Calculate speed PID Controller

//    PI_Speed_con();
    PI_const_update();

    if (speed_pid.Out>=0){ // speed_pid.Out은 float32
        setMotorControl(0,1);  //void setMotorControl(uint8 direction, uint8 enable)

        PWM_set((uint32)speed_pid.Out);      /* PWM_set 인자는 uint32  */

    }
    else { // 음수인 경우
        setMotorControl(1,1);  //void setMotorControl(uint8 direction, uint8 enable)
        speed_pid.Out = speed_pid.Out*(-1); // 음수 변환
        PWM_set((uint32)speed_pid.Out);      /* Change the intensity of the Motor  */
    }

    if (speed_pidB.Out>=0){ // 모터B용 speed_pidB
        setMotorControlB(1,1);  //void setMotorControl(uint8 direction, uint8 enable)
        // 값 잘 들어옴
        PWM_setB((uint32)speed_pidB.Out);      /* Change the intensity of the MotorB  */

    }
    else { // 음수인 경우
        setMotorControlB(0,1);  //void setMotorControl(uint8 direction, uint8 enable)
        speed_pidB.Out = speed_pidB.Out*(-1); // 음수 변환
        PWM_setB((uint32)speed_pidB.Out);      /* 이거 음수넣으면 안됨  */
    }

    //IfxStm_increaseCompare(STM, g_STMConf.comparator, g_ticksFor1ms);
}

//
void update_motor_rpm(Message_Info* msgptr){
    msgptr->vehicle_status.MSG.motor_cur_rpm = (motor_speed_rpm + motor_speed_rpmB)/2.0f;
}

/* Function to initialize the STM */
void initSTM(void)
{
    IfxStm_initCompareConfig(&g_STMConf);           /* Initialize the configuration structure with default values   */

    g_STMConf.triggerPriority = ISR_PRIORITY_STM;   /* Set the priority of the interrupt                            */
    g_STMConf.typeOfService = IfxSrc_Tos_cpu0;      /* Set the service provider for the interrupts                  */
    g_STMConf.ticks = g_ticksFor1ms;              /* Set the number of ticks after which the timer triggers an
                                                     * interrupt for the first time                                 */
    IfxStm_initCompare(STM, &g_STMConf);            /* Initialize the STM with the user configuration               */
}


/* Function to initialize all the peripherals and variables used */
void initPeripherals(void)
{
    /* Initialize time constant */
    g_ticksFor1ms = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, TIMER_INT_TIME);

    initSTM();                                      /* Configure the STM module                               */

}

// 여기부터 추가
// 각도 계산기 지금 사용 X
//void calculateWheelSpeeds(float32 steeringAngle, float32 *leftRPM, float32 *rightRPM)
//{
//    float32 W = 220.0;  // 차량 바퀴 간 거리 (mm)
//    float32 T = 0.1;  // 조향을 적용할 시간 (초)
//    float32 D = 65.0;  // 바퀴 지름 (mm)
//    float32 C = IFX_PI * D;  // 바퀴 둘레 (mm)
//
//    // 조향각도 제한 (-100° ~ 100°)
//    if (steeringAngle > 100.0) steeringAngle = 100.0;
//    if (steeringAngle < -100.0) steeringAngle = -100.0;
//
//    // 각속도 계산 (rad/s)
//    float32 omega = (steeringAngle * IFX_PI) / (180.0 * T);
//
//    // 바퀴 속도 차이 (mm/s)
//    float32 deltaV = (W * omega);
//
//    // mm/s → RPM 변환
//    float32 deltaRPM = (deltaV / C) * 60;
//
//    // 좌/우 바퀴 RPM 계산
//    if(deltaRPM > 0) *leftRPM += deltaRPM; // 속도 차 주기(우회전)
//    else *rightRPM += deltaRPM; // 속도 차 주기(좌회전)
//
//    // 속도 제한
//    if (*leftRPM > 330) *leftRPM = 330;
//    if (*rightRPM > 330) *rightRPM = 330;
//    if (*leftRPM < 0) *leftRPM = 0;
//    if (*rightRPM < 0) *rightRPM = 0;
//}


// 직진 함수
void goStraight(float32 speed)
{
    speed_pid.reset((void *)&speed_pid);
    speed_pid.Ref=speed;   // speed reference
//    speed_pid.Fdb= motor_speed_rpm; // speed measured by ENC
//    speed_pid.calc((void *)&speed_pid);   // Calculate speed PID Controller

    speed_pidB.reset((void *)&speed_pidB);
    speed_pidB.Ref=speed;   // speed reference float32
//    speed_pidB.Fdb= motor_speed_rpmB; // speed measured by ENC
//    speed_pidB.calc((void *)&speed_pidB);   // Calculate speed PID Controller
}

// 정지 함수 (모터를 정지시킴)
void stopMotors(void)
{
    speed_pid.reset((void *)&speed_pid);
    speed_pid.Ref = 0;
    speed_pid.ErrSum = 0; // 이거 추가해보기 완전 초기화??
//    motor_speed_rpm = 0; // 일단 주석
    setMotorControl(0,0);

    speed_pidB.reset((void *)&speed_pidB);
    speed_pidB.Ref = 0;
    speed_pidB.ErrSum = 0; // 이거 추가해보기 완전 초기화??
//    motor_speed_rpmB = 0; // 일단 주석
    setMotorControlB(0,0);
}

void calculate_motor_speeds(float32 steering_angle, float32 *left_rpm, float32 *right_rpm) {
    uint32 index;
    float32 AvgRPM, tan_value, delta_r;
    // 1. 조향 각도를 LUT 인덱스로 변환 (-60° ~ 60° -> 0 ~ 24)
    index = ((steering_angle + 60) / 5);
    if (index < 0) index = 0;
    if (index > 24) index = 24;

    AvgRPM = ( *left_rpm + *right_rpm ) / 2;

    // 2. 탄젠트 값 참조
    tan_value = tan_table[index];

    // 3. 모터 속도 차이 계산
    delta_r = AvgRPM * tan_value;
    test_temp = steering_angle;
    testC = delta_r;
    // 4. 좌우 모터 속도 계산
    *left_rpm = AvgRPM + (delta_r / 2);
    *right_rpm = AvgRPM - (delta_r / 2);
}

// 스티어링
void setSteeringControl(float32 steeringAngle)
{
    float32 leftSpeed, rightSpeed;
    leftSpeed = motor_speed_rpm;
    rightSpeed = motor_speed_rpmB; // 현재속도 업데이트

    // 좌/우 바퀴 속도 차이 계산 (양수각도 == 우회전)
    calculate_motor_speeds(steeringAngle, &leftSpeed, &rightSpeed);

    speed_pid.Ref=leftSpeed;   // speed reference
//    speed_pid.Fdb= motor_speed_rpm; // speed measured by ENC 여기 의심스러움
//    speed_pid.calc((void *)&speed_pid);   // Calculate speed PID Controller

    speed_pidB.Ref=rightSpeed;   // speed reference float32
//    speed_pidB.Fdb= motor_speed_rpmB; // speed measured by ENC
//    speed_pidB.calc((void *)&speed_pidB);   // Calculate speed PID Controller

    setMotorControl(0, 1);   // 왼쪽 모터 정방향 (-)
    setMotorControlB(1, 1);  // 오른쪽 모터 정방향
}
